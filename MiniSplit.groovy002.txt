/**
 *  Update Url:   https://raw.githubusercontent.com/arnbme/MiniSplitt/master/MiniSplitt.groovy
 *
 *  MiniSplit App
 *  Functions:
 *		Controls mini splits in conjuntcion with Broadlink IR blasters, and virtual thermostat.
 *        allows for using mini split Dry mode as part of cooling process
 *
 *  Copyright 2020 Arn Burkhoff
 *
 * 	Changes to Apache License
 *	4. Redistribution. Add paragraph 4e.
 *	4e. This software is free for Private Use. All derivatives and copies of this software must be free of any charges,
 *	 	and cannot be used for commercial purposes.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  Jun 25, 2020 v0.0.2	Delay temperature and coolSetPoint changes or 2 seconds allowing any thermostat operating modes to complete
 *						set fan operating mode to dry when using dry mode, otherwise set fan mode to on
 *  Jun 25, 2020 v0.0.1	Use thermostatModeHandler for all IR processing, dont set operating mode to dry
 *  Jun 25, 2020 v0.0.0	Create
 */

definition(
    name: "MiniSplit",
    namespace: "arnbme",
    author: "Arn Burkhoff",
    description: "(${version()}) Mini Split control app",
    category: "My Apps",
    iconUrl: "https://www.arnb.org/IMAGES/hourglass.png",
    iconX2Url: "https://www.arnb.org/IMAGES/hourglass@2x.png",
    iconX3Url: "https://www.arnb.org/IMAGES/hourglass@2x.png",
    singleInstance: true)

preferences {
    page(name: "mainPage")
	}

def version()
	{
	return "0.0.2";
	}

def mainPage()
	{
	dynamicPage(name: "main", title: "Mini Split Settings", install: true, uninstall: true)
		{
		section
			{
			input "globalDisable", "bool", required: true, defaultValue: false,
				title: "Disable All Functions. Default: Off/False"
			input "logDebugs", "bool", required: true, defaultValue: false,
				title: "Do debug logging. Shuts off after 30 minutes Default: Off/False"
			input "globalThermostat", "capability.thermostat", required: true, multiple: false,
				title: "A Thermostat that controls the Mini splits"
			input "globalIrBlasters", "capability.actuator", required: true, multiple: true,
				title: "One or More IR Blasters"
			}
		}
	}

def installed() {
    log.info "Installed with settings: ${settings}"
    initialize()
}

def updated() {
    log.info "Updated with settings: ${settings}"
    unsubscribe()
    initialize()
}

def initialize()
	{
	if(settings.logDebugs)
		runIn(1800,logsOff)			// turns off debug logging after 30 min
	else
		unschedule(logsOff)
	if (globalDisable)
		{}
	else
		{
		subscribe(globalThermostat, "thermostatOperatingState", thermostatModeHandler)
		subscribe(globalThermostat, "coolingSetpoint", temperatureHandler)
		subscribe(globalThermostat, "temperature", temperatureHandler)
		}
	}	

void logsOff(){
//	stops debug logging
	log.info "MiniSplit: debug logging disabled"
	app.updateSetting("logDebugs",[value:"false",type:"bool"])
}

def temperatureHandler(evt)
	{
//	Temperature or cooling setPoint changed on Thermostat
	if (settings.logDebugs) log.debug  "temperatureHandler entered Value: ${evt.value}  mode: ${globalThermostat.currentValue("thermostatMode")}"
//	if (globalThermostat.currentValue("thermostatMode") != 'cool') return
	pauseExecution(2000)				//allow any operating state change from the thermostat device to complete, its delayed dont know why
	thermostatModeHandler(evt)
	}

def thermostatModeHandler(evt)
	{
//	Thermostat Operating Mode changed, blast IR code to mini-splits
	def acMode = globalThermostat.currentValue("thermostatOperatingState")
	if (settings.logDebugs) log.debug  "thermostatModeHandler entered Value: ${evt.value} acMode: $acMode"
	def irCode='nada'
	def coolSetPoint = globalThermostat.currentValue("coolingSetpoint")
	def coolSetPointBD = coolSetPoint as BigDecimal
	def dryPoint = (((coolSetPointBD * 10) - 3)/10)
	switch (acMode)
		{
		case 'cooling':
			if (location.hsmStatus=='armedAway'|| globalThermostat.currentValue('thermostatMode') != 'cool')
				irCode='AC Off'
			else	
			if (globalThermostat.currentValue("temperature") < coolSetPointBD)
				irCode='ACDry74Swing'
			else
			if (coolSetPoint < 72) irCode='AC On2169'
			else
			if (coolSetPoint < 74) irCode='AC On2169'
			else
			if (coolSetPoint < 76) irCode='AC On2271'
			else
			if (coolSetPoint < 78) irCode='AC On2373'
			else
				irCode='AC On2475'
			break	
		default:
			irCode='AC Off'
			if (location.hsmStatus=='armedAway')
				{}
			else
			if (acMode=='idle' && globalThermostat.currentValue("thermostatMode") == 'cool' && globalThermostat.currentValue("temperature") >= dryPoint)
				irCode='ACDry74Swing'
		}	
	if (settings.logDebugs) log.debug  "thermostatModeHandler irCode: $irCode Prior irCode: ${state.priorIrCode}"
	if (irCode != state?.priorIrCode)
		{
		globalIrBlasters.SendStoredCode(irCode)
		state.priorIrCode=irCode
		if (irCode=='ACDry74Swing')
			globalThermostat.setThermostatFanMode('drying')
		else
		if (irCode=='AC Off')
			globalThermostat.setThermostatFanMode('off')
		else
			globalThermostat.setThermostatFanMode('cooling')
		}
	}